%% Ground_Truth_Fitting.m - Test MINDy on data generated by different systems

clear; clc; close all;
init_prj('MINDy_Base_v1.0');


%% Parameters

% Model and data
mdlName = 'HCP_Rest_FIX_Simple_Mdl200_sess';
mdlFile = fullfile('data', [mdlName, '.mat']);
datFile = replace(mdlFile, 'Mdl', 'Deconv');
nSubs = 3;  % Use a subset of data

% MINDy training
derivType = 'two-point';
nBatch = 5000;  % Actual number of batches used for training
% batchPerCP = 50;  % Save a checkpoint after every this number of batches (determined by MINDy_Base)
% nStopCP = nBatch / batchPerCP;

% MINDy simulations
slowThreshold = 1e-2;  % Discarding these frames (too slow)

% MINDy on simulations of linear systems
lmSimLen = 1200;  % Length of each segment of simulations (actual data is around 1200 TRs)
noiseScaling = 0.1;  % Noise = fitting error * noiseScaling

% Figure outputs
figdir = fullfile('figures', mdlName, 'Ground_Truth_Fitting');
if ~exist(figdir, 'dir')
    mkdir(figdir);
end


%% Load data and model

mf = matfile(mdlFile);
allMdl = mf.allMdl(1:nSubs, :);
nSess = size(allMdl, 2);
runIdx = mf.runIdx(1:nSubs, :);
df = matfile(datFile);
allDat = df.allDat(1:nSubs, :);
nParcels = size(allDat{1, 1}, 1);
clear mf df


%% Test MINDy on data generated by sparse linear MINDy and check landscape & reliability

noiseScaling = 1;
mindySimLen = 20;
doNorm = false;  % Whether to normalize the data before fitting MINDy

for i = 1:nSubs
    for j = 1:nSess

        % Sparse linear MINDy
        [splmmdl, dat, ddat] = MINDy_from_Deconv(allDat(i, runIdx{i, j}), 'Linear', derivType, nBatch, false);
        dat = [dat{:}];
        ddat = [ddat{:}];

        % Get standard form and check for stability
        if ~isempty(splmmdl.Param{5})
            W=splmmdl.Param{5};
        else
            W=splmmdl.Param{1};
        end
        slope=splmmdl.Param{2};
        D=splmmdl.Param{6};
        A = W .* slope + diag(1 - D);
        assert(all(abs(eig(A)) < 1), 'The linear system is not stable!');

        % Get prediction error
        errstd = std(A * dat - dat - ddat, 0, 2) * noiseScaling;

        % Generate data
        nTR = size(dat, 2);
        nSegs = ceil(nTR / mindySimLen);
        tmpDat = cell(1, nSegs);
        for k = 1:nSegs
            tmp = nan(nParcels, mindySimLen);
            tmp(:, 1) = randn(nParcels, 1);
            for l = 2:nTR
                tmp(:, l) = A * tmp(:, l - 1) + randn(nParcels, 1) .* errstd;
            end
            if doNorm
                tmp = zscore(tmp, 0, 2);
            end
            tmpDat{k} = tmp;
        end

        % Run MINDy
        mdl = MINDy_from_Deconv(tmpDat, 'Base', derivType, nBatch, false);  % Default stopping point & no checkpoints
        
        % Loop through two models
        tmpMdl = {allMdl{i, j}, mdl};
        tmpMdlName = {'MINDy on data', 'MINDy on sparse linear MINDy'};

        f = figure('Units', 'inches', 'Position', [0 0.5 20 10.0208]);
        t = tiledlayout(2, 4);

        for k = 1:2

            % Get motifs
            mdl = tmpMdl{k};
            [eq, lc, sims] = GetEqLC(mdl);
            lcmtf = LC2Motif(lc);
            mtf = [eq lcmtf{:}];

            % landscape
            nexttile();
            lgd = PlotAttractorLandscape(sims, eq, lcmtf, 3, 20);
            title(sprintf('%s landscape', tmpMdlName{k}));
            subtitle(sprintf('%d FP, %d LC', size(eq, 2), size(lc, 2)));

            % Connectivity
            nexttile();
            MyNetMatYeo(mdl.Param{5});
            title(sprintf('%s connectivity', tmpMdlName{k}));

            % Motifs
            for l = 1:2
                nexttile();
                PlotYeoSurface(mtf(:, l));
                colorbar;
                title(sprintf('%s motif %d', tmpMdlName{k}, l));
            end

        end
        lgd.Layout.Tile = 'west';
        title(t, sprintf('MINDy fitted on simulations of sparse linear MINDy (length = %d TR, noise scaling = %.2f, normalization = %s)', ...
            mindySimLen, noiseScaling, string(doNorm)));
        subtitle(t, sprintf('%s model, %s derivative, subject %d, session %d', mdlName, derivType, i, j), 'Interpreter', 'none');
        % PrintAsSeen(f, fullfile(figdir, ...
        %     ['MINDy_on_sparse_linear_lsim_' num2str(mindySimLen) '_scaled_normed_' mdlName '_sub' num2str(i) '_sess' num2str(j)]), '-dpng', '-r300');
    end
end


%% Test MINDy on data generated by the dense linear system and check landscape & reliability

noiseScaling = 1;
doNorm = false;  % Whether to normalize the data before fitting MINDy
diagLinear = false;  % Whether to use univariate (diagonal) linear system

lmMINDys = cell(nSubs, nSess);
allEq = cell(nSubs, nSess);
allLCMotif = cell(nSubs, nSess);

for i = 1:nSubs
    for j = 1:nSess

        % Dense linear model
        tmpX = cellfun(@(x) x(:, 1:end - 1), allDat(i, runIdx{i, j}), 'UniformOutput', false);
        tmpY = cellfun(@(x) x(:, 2:end), allDat(i, runIdx{i, j}), 'UniformOutput', false);
        tmpX = [tmpX{:}];
        tmpY = [tmpY{:}];
        nTR = size(tmpX, 2);
        if diagLinear
            A = zeros(nParcels);
            for k = 1:nParcels
                A(k, k) = tmpX(k, :)' \ tmpY(k, :)';
            end
        else
            A = (tmpX' \ tmpY')';
        end
        assert(all(real(eig(A)) < 1), 'The linear system is not stable!');
        errstd = std(A * tmpX - tmpY, 0, 2) * noiseScaling;

        % Generate data
        nSegs = ceil(nTR / lmSimLen);
        tmpDat = cell(1, nSegs);
        for k = 1:nSegs
            tmp = nan(nParcels, lmSimLen);
            tmp(:, 1) = randn(nParcels, 1);
            for l = 2:nTR
                tmp(:, l) = A * tmp(:, l - 1) + randn(nParcels, 1) .* errstd;
            end
            if doNorm
                tmp = zscore(tmp, 0, 2);
            end
            tmpDat{k} = tmp;
        end

        % Run MINDy
        mdl = MINDy_from_Deconv(tmpDat, 'Base', derivType, nBatch, false);  % Default stopping point & no checkpoints
        lmMINDys{i, j} = mdl;
        
        % Loop through two models
        tmpMdl = {allMdl{i, j}, mdl};
        tmpMdlName = {'MINDy on data', 'MINDy on dense linear'};

        f = figure('Units', 'inches', 'Position', [0 0.5 20 10.0208]);
        t = tiledlayout(2, 4);

        for k = 1:2

            % Get motifs
            mdl = tmpMdl{k};
            [eq, lc, sims] = GetEqLC(mdl);
            lcmtf = LC2Motif(lc);
            mtf = [eq lcmtf{:}];

            % landscape
            nexttile();
            lgd = PlotAttractorLandscape(sims, eq, lcmtf, 3, 20);
            title(sprintf('%s landscape', tmpMdlName{k}));
            subtitle(sprintf('%d FP, %d LC', size(eq, 2), size(lc, 2)));

            % Connectivity
            nexttile();
            MyNetMatYeo(mdl.Param{5});
            title(sprintf('%s connectivity', tmpMdlName{k}));

            % Motifs
            for l = 1:2
                nexttile();
                PlotYeoSurface(mtf(:, l));
                colorbar;
                title(sprintf('%s motif %d', tmpMdlName{k}, l));
            end

        end
        lgd.Layout.Tile = 'west';
        title(t, sprintf('MINDy fitted on noisy simulations of dense linear system (length = %d TR, noise scaling = %.2f, normalization = %s)', ...
            lmSimLen, noiseScaling, string(doNorm)));
        subtitle(t, sprintf('%s model, %s derivative, subject %d, session %d', mdlName, derivType, i, j), 'Interpreter', 'none');
        PrintAsSeen(f, fullfile(figdir, ...
            ['MINDy_on_dense_linear_lsim_' num2str(lmSimLen) '_scaled_normed_' mdlName '_sub' num2str(i) '_sess' num2str(j)]), '-dpng', '-r300');
    end
end



%% MINDy - MINDy

% Actual simulation will be cut when speed drops below |slowThreshold|
MINDySimLen = 20;
MINDyNBatch = nBatch;  % Optionl longer training time
noiseScaling = 1;  % Default noise level is the same as the residual on fMRI data
NoDiag = true;  % Whether to remove diagonal elements in the connectivity matrix

if NoDiag
    mdlType = 'NoDiag';
else
    mdlType = 'Base';
end

% Number of Yeo networks (just a constant)
nYeoNet = 17;

mmMINDys = cell(nSubs, nSess);
for i = 1:nSubs
    f = figure('Units', 'inches', 'Position', [0 0.5 20 10.0208]);
    t = tiledlayout(nSess, 4, 'TileSpacing', 'loose');
    for j = 1:nSess

        disp("Subject " + i + ", session " + j)

        % Refit MINDy and get prediction error
        disp("Refitting MINDy on data...")
        [mdl, tmpX, tmpY] = MINDy_from_Deconv(allDat(i, runIdx{i, j}), mdlType, derivType, nBatch, false);
        tmpX = [tmpX{:}];
        tmpY = [tmpY{:}];
        pred = MINDyInt_00(mdl, tmpX, 1, 1, 0, 1);
        pred = squeeze(pred(:, end, :) - pred(:, 1, :));
        errstd = std(tmpY - pred, 0, 2);
%         errstd = errstd(randperm(length(errstd)));  % Optional randperm
        R2 = 1 - (errstd ./ std(tmpY, 0, 2)) .^ 2;

        % Get motifs
        [eq, lc] = GetEqLC(mdl);

        % Visualize connectivity
        nexttile(tilenum(t, j, 1));
        MyNetMatYeo(mdl.Param{5});
        cl1 = clim();
        title('Connectivity (MINDy on data)');
        subtitle(sprintf('Mean R^2 = %.2f, %d FP, %d LC', mean(R2), size(eq, 2), size(lc, 2)))

        % % Visualize Jacobian at the origin
        % tmp = EqFinder(mdl);
        % J = tmp.J(zeros(nParcels, 1));
        % nexttile(tilenum(t, j, 3));
        % MyNetMatYeo(J);
        % cl2 = clim();
        % title('Jacobian at the origin (MINDy)');
        % subtitle(sprintf('Number of unstable dimensions: %d', sum(real(eig(J)) > 0)))

        % Visualize decay
        nexttile(tilenum(t, j, 3));
        PlotYeoSurface(mdl.Param{6});
        cl2 = clim(); colorbar;
        title('Decay D (MINDy on data)');
        subtitle(sprintf('mean curvature \\alpha = %.2f', mean(mdl.Param{2})))

        % Simulate MINDy and fit MINDy on simulations
        disp("Simulating MINDy and fitting MINDy on simulations...")
        errstd = errstd * noiseScaling; % Noise scaling
        nTR = size(tmpX, 2);
        nSegs = ceil(nTR / MINDySimLen);
        tmpDat = cell(1, nSegs);
        for k = 1:nSegs            
            tmp = MINDyInt_00(mdl, tmpX(:, randperm(nTR, 1)), 1, 1, errstd, MINDySimLen - 1);
            tmpDat{k} = tmp;
        end
        simlen = round(mean(cellfun(@(x) size(x, 2), tmpDat)));
        [mmMINDys{i, j}, dat, ddat] = MINDy_from_Deconv(tmpDat, mdlType, 'one-point', MINDyNBatch, true);

        % Get motifs
        [eq, lc] = GetEqLC(mmMINDys{i, j});

        % Get R2 of MINDy on MINDy
        dat = [dat{:}];
        ddat = [ddat{:}];
        pred = MINDyInt_00(mmMINDys{i, j}, dat, 1, 1, 0, 1);
        pred = squeeze(pred(:, end, :) - pred(:, 1, :));
        errstd = std(ddat - pred, 0, 2);
        R2 = 1 - (errstd ./ std(ddat, 0, 2)) .^ 2;
        rhoW = offdiagcorr(mdl.Param{5}, mmMINDys{i, j}.Param{5});
        rhoD = corr(mdl.Param{6}, mmMINDys{i, j}.Param{6});
        rhoA = corr(mdl.Param{2}, mmMINDys{i, j}.Param{2});

        % Visualize connectivity
        nexttile(tilenum(t, j, 2));
        MyNetMatYeo(mmMINDys{i, j}.Param{5});
        clim(cl1); colorbar off;
        % Remove y labels
        idx = find(isgraphics(gca().Children, 'Text'), nYeoNet, "first");
        delete(gca().Children(idx));
        title('Connectivity (MINDy on MINDy)');
        subtitle(sprintf('Mean R^2 = %.2f, %d FP, %d LC, \\rho(W_{offdiag}) = %.2f', ...
            mean(R2), size(eq, 2), size(lc, 2), rhoW))

        % % Visualize Jacobian at the origin
        % tmp = EqFinder(mmMINDys{i, j});
        % J = tmp.J(zeros(nParcels, 1));
        % nexttile(tilenum(t, j, 4));
        % MyNetMatYeo(J);
        % clim(cl2); colorbar off;
        % % Remove y labels
        % idx = find(isgraphics(gca().Children, 'Text'), nYeoNet, "first");
        % delete(gca().Children(idx));
        % title('Jacobian at the origin (MINDy on MINDy)');
        % subtitle(sprintf('Number of unstable dimensions: %d', sum(real(eig(J)) > 0)))

        % Visualize decay
        nexttile(tilenum(t, j, 4));
        PlotYeoSurface(mmMINDys{i, j}.Param{6});
        clim(cl2); colorbar off;
        title('Decay D (MINDy on MINDy)');
        subtitle(sprintf('mean curvature \\alpha = %.2f, \\rho(D) = %.2f, \\rho(\\alpha) = %.2f', ...
            mean(mmMINDys{i, j}.Param{2}), rhoD, rhoA))

    end
    nexttile('west');
    for j = 1:nSess
        text(0, -j, "Session " + j, 'FontSize', 12, 'FontWeight', 'bold', ...
            'HorizontalAlignment', 'center', 'VerticalAlignment', 'middle');
    end
    xlim([-0.2 1])
    ylim([-nSess - 0.5, -0.5]);
    axis off;

    title(t, sprintf('Participant %d, %s model, one-point derivative fit on MINDy simulations', i, mdlName), 'Interpreter', 'none');
    subtitle(t, sprintf('MINDy type: %s; simulation time: %d TRs; Noise scaling: %.2f', mdlType, MINDySimLen, noiseScaling));

    if noiseScaling == 1
        tmpstr = 'unscaled';
    elseif noiseScaling == 0
        tmpstr = 'noise-free';
    else
        tmpstr = 'scaled';
    end
%     PrintAsSeen(f, fullfile(figdir, ['MINDy_MINDysim_' num2str(MINDySimLen) '_' tmpstr ...
%         '_' mdlType '_sub' num2str(i)]), '-dpng', '-r300');
end


%% MINDy - Dense linear - MINDy

% use a different simulation length
MINDySimLen = 20;
lmSimLen = 20;
noiseScaling = 0.1;

mmMINDys = cell(nSubs, nSess);
mlmMINDys = cell(nSubs, nSess);
for i = 1:nSubs
    f = figure('Units', 'inches', 'Position', [0 0.5 20 10.0208]);
    t = tiledlayout(nSess, 4, 'TileSpacing', 'loose');
    for j = 1:nSess

        disp("Subject " + i + ", session " + j)

        % Get prediction error of fitted MINDy models
        mdl = allMdl{i, j};
        switch derivType
            case 'two-point'
                tmpX = cellfun(@(x) x(:, 1:end - 2), allDat(i, runIdx{i, j}), 'UniformOutput', false);
                tmpY = cellfun(@(x) (x(:, 3:end) - x(:, 1:end - 2)) / 2, allDat(i, runIdx{i, j}), 'UniformOutput', false);
            case 'one-point'
                tmpX = cellfun(@(x) x(:, 1:end - 1), allDat(i, runIdx{i, j}), 'UniformOutput', false);
                tmpY = cellfun(@(x) x(:, 2:end) - x(:, 1:end - 1), allDat(i, runIdx{i, j}), 'UniformOutput', false);
            case 'center'
                tmpX = cellfun(@(x) x(:, 2:end - 1), allDat(i, runIdx{i, j}), 'UniformOutput', false);
                tmpY = cellfun(@(x) (x(:, 3:end) - x(:, 1:end - 2)) / 2, allDat(i, runIdx{i, j}), 'UniformOutput', false);
        end
        tmpX = [tmpX{:}];
        tmpY = [tmpY{:}];
        pred = MINDyInt_00(mdl, tmpX, 1, 1, 0, 1);
        pred = squeeze(pred(:, end, :) - pred(:, 1, :));
        errstd = std(tmpY - pred, 0, 2);
        R2 = 1 - (errstd ./ std(tmpY, 0, 2)) .^ 2;

        % Noise scaling
        errstd = errstd * noiseScaling;

        % Get motifs
        [eq, lc, sims] = GetEqLC(mdl);
%         lcmtf = LC2Motif(lc);
%         nexttile;
%         PlotAttractorLandscape(sims, eq, lcmtf, 3, 20);
%         title(sprintf('Session %d, Fitted model (mean R^2 = %.2f)', j, mean(R2)));
%         subtitle(sprintf('%d FP, %d LC', size(eq, 2), size(lc, 2)));

        % Show connectivity matrix
        nexttile;
        MyNetMatYeo(mdl.Param{5});
        cl = clim();
        title('MINDy on data');
        subtitle(sprintf('Mean R^2 = %.2f, %d FP, %d LC', mean(R2), size(eq, 2), size(lc, 2)))

        % Simulate MINDy and fit MINDy on simulations
        nTR = size(tmpX, 2);
        nSegs = ceil(nTR / MINDySimLen);
        tmpDat = cell(1, nSegs);
        for k = 1:nSegs            
            tmpDat{k} = MINDyInt_00(mdl, tmpX(:, randperm(nTR, 1)), 1, 1, errstd, MINDySimLen - 1);
        end
        [mmMINDys{i, j}, dat, ddat] = MINDy_from_Deconv(tmpDat, 'Base', 'one-point', nBatch, false);

        % Get R2 of MINDy on MINDy
        dat = [dat{:}];
        ddat = [ddat{:}];
        pred = MINDyInt_00(mmMINDys{i, j}, dat, 1, 1, 0, 1);
        pred = squeeze(pred(:, end, :) - pred(:, 1, :));
        errstd = std(ddat - pred, 0, 2);
        R2 = 1 - (errstd ./ std(ddat, 0, 2)) .^ 2;
        rhoW = offdiagcorr(mdl.Param{5}, mmMINDys{i, j}.Param{5});

        % Show connectivity matrix
        [eq, lc, sims] = GetEqLC(mmMINDys{i, j});
        nexttile;
        MyNetMatYeo(mmMINDys{i, j}.Param{5});
        clim(cl); colorbar off;
        % Remove y labels
        idx = find(isgraphics(gca().Children, 'Text'), nYeoNet, "first");
        delete(gca().Children(idx));
        title(sprintf('MINDy on MINDy simulations'));
        subtitle(sprintf('Mean R^2 = %.2f, %d FP, %d LC, \\rho(W_{offdiag}) = %.2f', ...
            mean(R2), size(eq, 2), size(lc, 2), rhoW))

        % Fit dense linear model on simulations
        tmpDat = [tmpDat{:}];
        tmpX = tmpDat(:, 1:end - 1);
        tmpY = tmpDat(:, 2:end);
        A = (tmpX' \ tmpY')';
        AisStable = all(real(eig(A)) < 1);
        if ~AisStable
            warning('The linear system is not stable!');
            tmpstr = 'unstable';
        else
            tmpstr = 'stable';
        end
        errstd = std(A * tmpX - tmpY, 0, 2);
        R2 = 1 - (errstd ./ std(tmpY, 0, 2)) .^ 2;
        rhoW = offdiagcorr(mdl.Param{5}, A);

        % Show dense linear
        nexttile;
        MyNetMatYeo(A);
        % Remove y labels
        idx = find(isgraphics(gca().Children, 'Text'), nYeoNet, "first");
        delete(gca().Children(idx));
        title('Dense linear model on MINDy simulations')
        subtitle(sprintf('Mean R^2 = %.2f, \\rho(W_{offdiag}) = %.2f, %s', mean(R2), rhoW, tmpstr))

        % Simulate dense linear and fit MINDy
        nSegs = ceil(nTR / lmSimLen);
        tmpDat = cell(1, nSegs);
        for k = 1:nSegs
            tmp = nan(nParcels, lmSimLen);
            tmp(:, 1) = randn(nParcels, 1);
            for l = 2:nTR
                tmp(:, l) = A * tmp(:, l - 1) + randn(nParcels, 1) .* errstd;
            end
            tmpDat{k} = tmp;
        end
        [mlmMINDys{i, j}, dat, ddat] = MINDy_from_Deconv(tmpDat, 'Base', 'one-point', nBatch, false);

        % Get R2 of MINDy on dense linear
        dat = [dat{:}];
        ddat = [ddat{:}];
        pred = MINDyInt_00(mlmMINDys{i, j}, dat, 1, 1, 0, 1);
        pred = squeeze(pred(:, end, :) - pred(:, 1, :));
        errstd = std(ddat - pred, 0, 2);
        R2 = 1 - (errstd ./ std(ddat, 0, 2)) .^ 2;
        rhoW = offdiagcorr(mdl.Param{5}, mlmMINDys{i, j}.Param{5});

        % Get motifs
        [eq, lc, sims] = GetEqLC(mlmMINDys{i, j});
        % lcmtf = LC2Motif(lc);
        % nexttile;
        % lgd = PlotAttractorLandscape(sims, eq, lcmtf, 3, 20);
        % title(sprintf('Session %d, MINDy fitted on dense linear', j));
        % subtitle(sprintf('%d FP, %d LC', size(eq, 2), size(lc, 2)));

        % Show connectivity matrix
        nexttile;
        MyNetMatYeo(mlmMINDys{i, j}.Param{5});
        clim(cl); colorbar off;
        % Remove y labels
        idx = find(isgraphics(gca().Children, 'Text'), nYeoNet, "first");
        delete(gca().Children(idx));
        title('MINDy on dense linear simulations');
        subtitle(sprintf('Mean R^2 = %.2f, %d FP, %d LC, \\rho(W_{offdiag}) = %.2f', ...
            mean(R2), size(eq, 2), size(lc, 2), rhoW))
        
    end
%     lgd.Layout.Tile = 'east';
%     lgd.Visible = 'on';

    % Add session labels
    nexttile('west');
    for j = 1:nSess
        text(0, -j, "Session " + j, 'FontSize', 12, 'FontWeight', 'bold', ...
            'HorizontalAlignment', 'center', 'VerticalAlignment', 'middle');
    end
    xlim([-0.2 1])
    ylim([-nSess - 0.5, -0.5]);
    axis off;

    title(t, sprintf('Participant %d, %s model, one-point derivative fit on MINDy simulations (noise scaling = %.2f)', ...
        i, mdlName, noiseScaling), 'Interpreter', 'none');
    subtitle(t, sprintf('MINDy simulation time: %d TRs; Linear model simulation time: %d TRs', MINDySimLen, lmSimLen));

    if noiseScaling == 1
        tmpstr = 'unscaled';
    elseif noiseScaling == 0
        tmpstr = 'noise-free';
    else
        tmpstr = 'scaled';
    end
    PrintAsSeen(f, fullfile(figdir, ['MLM_MINDysim_' num2str(MINDySimLen) '_lmsim_' num2str(lmSimLen) '_' tmpstr '_' mdlName '_sub' num2str(i)]), '-dpng', '-r300');
end


%% Clean up

close all;